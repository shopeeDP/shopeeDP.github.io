<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo+github搭建个人博客]]></title>
    <url>%2F2018%2F07%2F20%2Fhexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这个博客的搭建使用的是静态博客搭建框架hexo，配与next作为博客主题，最后将博客放到github上。省去了申请域名等麻烦的工作，使得搭建博客变得轻松简单。 Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown或其他渲染引擎解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Next是hexo下的一个主题，在hexo中，阔以通过切换主题实现博客外观的改变。 安装Hexo依赖 Node.js git 需要电脑上先安装好Node.js和git 然后是安装hexo1npm install -g hexo 安装完毕后，选择一个文件夹，执行hexo init指令生成建立博客所需要的文件1hexo init 接着是安装所需要的依赖1npm install 等待依赖安装的过程可以看一下hexo的一些常用命令，不需要记，后面用到了再来看就行12345hexo g # hexo generate 命令的简写，用于生成静态文件hexo s # hexo server 命令的简写，用于启动服务器进行本地预览hexo d # hexo deploy 命令的简写，用于将本地文件发布到github上hexo n # hexo new 命令的简写，用于新建一篇文章hexo clean # 清除缓存文件（db.json）和已生成的静态文件（public） 在依赖安装完毕后，执行hexo g和hexo s，生成静态文件并启动服务器12hexo ghexo s 可以看到博客已经运行在 localhost:4000 端口上了，打开浏览器访问该地址即可以看到我们的博客已经搭建起来了，在这里可以非常方便地进行本地预览。更多细节可以参考官方文档 主题hexo默认使用的主题是landscape，我这里使用了最近比较流行的next主题。hexo安装主题的过程十分简单，在目录下找到themes文件夹，将要使用的主题文件夹拷入其中，再稍微修改一下配置即可。 安装nextnext有两种安装方式第一种是直接使用 git 克隆到themes文件夹，之后也可以直接通过git pull进行更新12// 定位至themes文件夹目录下git clone https://github.com/iissnan/hexo-theme-next 第二种是下载压缩包，然后解压至themes文件夹next版本发布页面 启用主题把next放入themes文件夹后，找到站点配置文件（根目录下的_config.yml文件），将theme字段的值改为next。如图所示 这时候执行ctrl + C中止本地服务器，然后通过hexo clean清除缓存后，再启动服务器，就可以看到博客的主题已经变成了next了。12hexo cleanhexo s next有很多可以自行配置的设定，如主题设定，语言设定，菜单设定，侧栏设定等等，还有很多诸如评论系统，内容分享，数据统计等强大功能。这里先埋个坑，不多赘述，详情可以前往next官网查看，以后有时间再补充。 部署到githubgithub仓库配置本地预览得满意了，下一步当然就是部署到网上给别人观赏~如果还未拥有github账号，就先去注册申请一个。 新建一个仓库，名字必须是你的github账号名.github.io如图所示，我的账号名是Darkindom，所以我的仓库名相应的就是Darkindom.github.io(这里仓库名前面要和你的账号名一致) 部署本地文件找到站点配置文件（根目录下的_config.yml文件），将其中的deploy改成以下格式（如果没有该字段就新建一个）。 这里如果是第一次使用github，或者更改过账号，可能需要重新配置一下SSH（因为之前使用公司的博客时，用的是另一个github账号，所以切换回来后部署的时候说权限错误，就需要重新配置SSH） 输入以下命令，如果提示要你输入的时候可以先输入回车，如果提示是否要覆盖原先SSH(y/n)输入y1ssh-keygen -t rsa -C &apos;your@email.com&apos; 接着输入以下命令1ssh-agent -s 如果这一步出错，就输入以下命令12eval `ssh-agent -s`ssh-add 接下来就可以把SSH拷贝出来，添加到github账户上了1cat ~/.ssh/id_rsa.pub 将控制台里的那一长串SSH拷贝，打开github账户title随便起一个自己容易辨别的，key里粘贴刚刚复制的SSH 最后测试一下，1ssh -T git@github.com 显示这样就是SSH配置好了 执行hexo g，hexo d部署到github上12hexo ghexo d 如果报了Error Deployer not found: git的错就安装hexo-deployer-git模块1npm install --save hexo-deployer-git 再执行hexo d,完成部署。打开浏览器，输入地址，比如我的就是https://darkindom.github.io/ 大功告成~！ 发布文章关于发布文章的可以看我的另一篇博客《使用hexo写文章》这里再提一点，多人合作的话可以将博客的相关代码保存在另一个git仓库，这样每次发布或者修改文章了，都可以备份到另一个仓库里，然后给权限即可。 参考嘟嘟独立博客 hexo干活系列：（一）hexo+github搭建个人独立博客 | 作者：Dk]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dp 项目部署说明]]></title>
    <url>%2F2018%2F07%2F11%2Fshopee-deploy%2F</url>
    <content type="text"><![CDATA[shopee 前端项目部署涉及的点比较多，且部署过程中有些环节对于我们开发人员来说是黑盒， 很容易掉坑，为了 降低大家的采坑 概率，将自己摸索的经验总结如下 点击前往 | 作者：ayou]]></content>
      <categories>
        <category>项目文档</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F07%2F11%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用git命令一、git状态工作区域工作区：日常编辑代码的地方本地仓库：保存本地提交记录暂存区：相当于工作区和本地仓库中简的缓存，代表要提交代码的一个工作状态，维护的是一个虚拟的树形结构 文件变化周期添加一个新文件A，A处于 Untracked 状态，通过add将其加至暂存区，A变成 Staged 状态，通过commit提交，A变成 Unmodified 状态，对 Unmodified 状态的文件进行修改，就变成 Unmodified 状态，删除文件，将会使其变成 Untracked 状态 二、基本config123456789查看git配置git config --list编辑git配置git config -e [--global]设置用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[emali]&quot; status12显示工作目录和暂存区的状态git status log1234567891011121314151617查看提交历史git log--oneline 将每个提交放在一行显示git log --oneline--stat，仅显示简要的增改行数统计git log --stat--grep，搜索提交说明中的关键字git log --grep keywords-p 选项展开显示每次提交的内容差异git log -p -- file/path显示所有提交过的用户，按提交次数排序git shortlog -sn diff1234567891011比较暂存区和工作区的差异git diff比较暂存区和上一个commit的差异git diff --cached比较工作区与指定commit-id的差异git diff &lt;commit&gt; [path]显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; 三、本地add1234567891011121314添加文件到暂存区git add [file...]添加指定路径的文件到暂存区git add [path]将所有文件从工作区添加到暂存区，包括修改的、新建的，但不包括删除的git add .将所有文件从工作区添加到暂存区，包括修改的、删除的，但不包括新建的git add -u将所有文件从工作区添加到暂存区，包括修改的、删除的、新建的git add -A commit1234567891011将文件从暂存区提交至本地仓库git commit -m &quot;[your message]&quot;撤销上一次提交git commit --amend将工作区自从上次提交之后的变化 提交至本地仓库git commit -a提交时显示所有diff信息git commit -v branch1234567891011121314151617181920212223242526显示所有本地分支git branch显示所有远程分支git branch -r显示所有分支，包括本地和远程git branch -a新建一个分支，以branch-name命名git branch &lt;branch-name&gt;将old branch分支重命名为new branchgit branch -m &lt;old branch&gt; &lt;new branch&gt;将branch分支强制移动至new place提交位置git branch -f &lt;branch&gt; [new place]新建一个分支branch，并与远程分支remote-branch建立追踪关系git branch --track &lt;branch&gt; &lt;remote-branch&gt;将本地分支branch与远程分支remote-branch建立追踪关系git branch --set-upstream &lt;branch&gt; &lt;remote-branch&gt;删除远程分支git branch -dr [remote/branch] checkout12345678切换至分支branchgit checkout &lt;branch&gt;新建并切换至分支new branchgit checkout -b [new branch]切换至上一个进行操作的分支git checkout - cherry-pick12将指定提交选定，并合进当前分支git cherry-pick &lt;commit 1&gt; ... &lt;commit n&gt; rebase123456以线性关系合并branchgit rebase &lt;upstream&gt; &lt;branch&gt;修改提交历史。startpoint, endpoint 表示一个编辑区间。endpoint如果不指定则默认当前HEAD所指向的commitgit rebase -i &lt;start point&gt; &lt;end point&gt; 四、远程clone12克隆远程仓库git clone remote1234567891011显示所有远程仓库git remote -v显示指定远程仓库git remote show &lt;remote&gt;添加一个远程仓库，并命名为 new namegit remote add &lt;new name&gt; &lt;url&gt;修改远程仓库的地址git remote set-url origin &lt;url&gt; fetch123456下载远程仓库所有变动git fetch从remote仓库的source获取提交记录，放到本地的destination上，如果没有source，将以destination创建一个新分支在本地git fetch &lt;remote&gt; &lt;source&gt;:&lt;destination&gt; pull123456789下载远程仓库的变动并更新至本地git pull从remote仓库的source获取提交记录，放到本地的destination上，最后将destination合并到当前分支上如果没有source，将以destination创建一个新分支在本地，再进行合并git pull &lt;remote&gt; &lt;source&gt;:&lt;destination&gt;以rebase的方式合并提交，相当于执行git fetch; git rebasegit pull --rebase push123456789101112将本地仓库的变动提交至远程仓库git push将本地仓库的source的提交上传至remote远程仓库的destination上如果没有source，将创建一个destination分支git push &lt;remote&gt; &lt;source&gt;:&lt;destination&gt;强行推送当前分支到远程仓库，即使有冲突git push [remote] --force推送所有分支到远程仓库git push [remote] --all 五、撤销checkout12345将所有暂存区的文件恢复到工作区git checkout .将指定暂存区的文件恢复到工作区git checkout &lt;file&gt; commit12重写上一次commitgit commit --amend merge12抛弃合并git merge --abort reset12345678910111213141516重置暂存区的指定文件git reset &lt;file&gt;重置当前分支的指针为指定提交，重置暂存区，工作区不变commit默认是HEAD，相当于git add的反操作git reset &lt;commit&gt;工作区不改变，但是暂存区会回退到上一次提交之前，HEAD回到上一个提交。git reset --mixed HEAD^工作区和暂存区不改变，HEAD回到上一个提交，即撤销最新的提交。git reset --sort HEAD^撤销最近的提交，工作区和暂存区都会回退到上一次提交的状态HEAD回到上一个提交，即自上一次以来的提交全部丢失。git reset --hard HEAD^ revert12新建一个提交，来撤销指定的提交git revert [commit] stash12345暂时将未提交的变化保存起来git stash恢复之前未提交的变化git stash pop | 作者：Dk]]></content>
      <categories>
        <category>组内分享</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析 webpack 打包机制]]></title>
    <url>%2F2018%2F07%2F11%2Fwebpack-bundle-dive-into%2F</url>
    <content type="text"><![CDATA[从最基本的开始首先，让我们从一个简单的例子开始： 12345678src js constants.js index.js utils.js index.htmlpackage.jsonwebpack.config.js 其中，各文件内容如下： 1234567891011121314151617181920212223242526272829303132333435// index.jsconst sum = require('./utils').sumconst CONST = require('./constants')console.log(sum(1, 2))console.log(CONST.version)// utils.jsexports.sum = (a, b) =&gt; &#123; return a + b&#125;// constants.jsmodule.exports = &#123; version: '1.1.0'&#125;// webpack.config.jsconst path = require('path')module.exports = &#123; entry: './src/js/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;// index.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;...&lt;body&gt;&lt;div&gt;hello&lt;/div&gt; &lt;script src="./dist/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打包出的结果经过简化后如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// webpackBootstrap 启动函数// modules 即为存放所有模块的数组，数组中的每一个元素都是一个函数(function (modules) &#123; // 安装后的模块缓存在该对象中 var installedModules = &#123;&#125;; // 模块加载函数，跟 node.js 中的 require 语句类似 // moduleId 为模块在数组 modules 中的索引 function __webpack_require__(moduleId) &#123; // 如果模块已经加载过，直接从缓存中返回 if (installedModules[moduleId]) return installedModules[moduleId].exports; // 如果缓存中不存在需要加载的模块，就新建一个模块，存放在缓存中 var module = installedModules[moduleId] = &#123; i: moduleId, // 模块在数组中的索引 l: false, // 还未加载 exports: &#123;&#125; // 该模块的导出对象 &#125;; // 执行模块函数 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 将模块标记为已加载 module.l = true; // 返回该模块的导出对象 return module.exports; &#125; // 使用 __webpack_require__ 去加载 index 为 2 的模块，并且返回该模块导出的对象 // __webpack_require__.s 表示该模块是启动模块 return __webpack_require__(__webpack_require__.s = 2);&#125;)([ /* 0 */ (function (module, exports) &#123; module.exports = &#123; version: '1.1.0' &#125; &#125;), /* 1 */ (function (module, exports) &#123; exports.sum = (a, b) =&gt; &#123; return a + b &#125; &#125;), /* 2 */ (function (module, exports, __webpack_require__) &#123; const sum = __webpack_require__(1).sum const CONST = __webpack_require__(0) console.log(sum(1, 2)) console.log(CONST.version) &#125;)]); 打包后的结果是一个自执行函数，其参数是一个数组，存储了各个模块，每个模块就是一个函数，其参数分别为 module, exports, __webpack_require__，每个模块以数组下标作为模块的 id。 自执行函数中定义了函数 __webpack_require__(moduleId)， 该函数类似于 nodejs 中的 require，其参数为模块 id，该函数首先判断模块是否已加载到 installedModules 对象之中，如果是，则直接返回缓存的结果，否则就新创建一个模块对象，并执行模块对应的函数，最后返回模块导出的内容。 自执行函数最后调用 __webpack_require__(__webpack_require__.s = 2) 并传入了入口模块的 id，这样整个应用就跑起来了。 模块异步加载假设我们的入口模块代码如下： 123456789101112131415import('./page1').then(page =&gt; &#123; console.log(page)&#125;)import('./page2').then(page =&gt; &#123; console.log(page)&#125;)import('./page3').then(page =&gt; &#123; console.log(page)&#125;)import('./page4').then(page =&gt; &#123; console.log(page)&#125;) 打包后的结果： bundle.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147(function(modules) &#123; // webpackBootstrap // install a JSONP callback for chunk loading var parentJsonpFunction = window["webpackJsonp"]; /** * 从异步加载的文件中安装模块 * @param &#123;*&#125; chunkIds 异步加载的文件中存放的需要安装的模块对应的 chunk id（包括自己），可以理解为所依赖的 chunk id * @param &#123;*&#125; moreModules 表示该 chunk 加载后新带来的 modules * @param &#123;*&#125; executeModules 需要执行的模块，可能为空 */ window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) &#123; var moduleId, chunkId, i = 0, resolves = [], result; for(;i &lt; chunkIds.length; i++) &#123; chunkId = chunkIds[i]; if(installedChunks[chunkId]) // 将 resolve 放到队列中后面统一执行 resolves.push(installedChunks[chunkId][0]); // 标记该 chunk 加载成功 installedChunks[chunkId] = 0; &#125; // 将 chunk 中的 modules 合并到 modules 中 for(moduleId in moreModules) &#123; if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; modules[moduleId] = moreModules[moduleId]; &#125; &#125; if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules); while(resolves.length) resolves.shift()(); &#125;; // The module cache var installedModules = &#123;&#125;; // objects to store loaded and loading chunks var installedChunks = &#123; 4: 0 &#125;; // The require function function __webpack_require__(moduleId) &#123; // Check if module is in cache if(installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.l = true; // Return the exports of the module return module.exports; &#125; /** * 异步加载分割出去的chunk对应的文件 * @param &#123;*&#125; chunkId 需要异步加载的 chunk 对应的 id */ __webpack_require__.e = function requireEnsure(chunkId) &#123; // 状态为 0 表示已经加载过 if(installedChunks[chunkId] === 0) return Promise.resolve(); // 不为 0 且不为空，表示正在加载，其实返回的是一个 Promise 对象，后面会看到 if(installedChunks[chunkId]) &#123; return installedChunks[chunkId][2]; &#125; // 通过 dom 操作插入 script 标签来异步加载 chunk 对应的 js 文件 var head = document.getElementsByTagName('head')[0]; var script = document.createElement('script'); script.type = 'text/javascript'; script.charset = 'utf-8'; script.async = true; script.timeout = 120000; // CSP 相关 if (__webpack_require__.nc) &#123; script.setAttribute("nonce", __webpack_require__.nc); &#125; // 文件的路径由配置的 publicPath, chunkId 拼接而成 script.src = __webpack_require__.p + "" + chunkId + ".bundle.js"; // 异步加载超时时间 var timeout = setTimeout(onScriptComplete, 120000); // 加载失败或成功的回调函数 script.onerror = script.onload = onScriptComplete; function onScriptComplete() &#123; // 防止 IE 中内存泄漏 script.onerror = script.onload = null; clearTimeout(timeout); // 检查 chunk 是否加载成功，如果不成功则 reject var chunk = installedChunks[chunkId]; if(chunk !== 0) &#123; if(chunk) chunk[1](new Error('Loading chunk ' + chunkId + ' failed.')); installedChunks[chunkId] = undefined; &#125; &#125;; // 返回的 promise，初始化 installedChunks[chunkId] 为 [resolve, reject, promise] // 什么时候 resolve ? var promise = new Promise(function(resolve, reject) &#123; installedChunks[chunkId] = [resolve, reject]; &#125;); installedChunks[chunkId][2] = promise; head.appendChild(script); return promise; &#125;; // __webpack_public_path__ __webpack_require__.p = "dist/"; // Load entry module and return exports return __webpack_require__(__webpack_require__.s = 4);&#125;)(&#123;// 0 - 3 的 modules 被分割出去了/***/ 4:/***/ (function(module, exports, __webpack_require__) &#123;__webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, 0)).then(page =&gt; &#123; console.log(page)&#125;)__webpack_require__.e/* import() */(2).then(__webpack_require__.bind(null, 1)).then(page =&gt; &#123; console.log(page)&#125;)__webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 2)).then(page =&gt; &#123; console.log(page)&#125;)__webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 3)).then(page =&gt; &#123; console.log(page)&#125;)/***/ &#125;)&#125;); 0.bundle.js 1234567891011webpackJsonp([0],&#123;/***/ 3:/***/ (function(module, exports) &#123;exports.name = 'page1'/***/ &#125;)&#125;); bundle.js 中 modules[4] 模块中执行的 __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 3)).then(...) 可以分解为两步：其中 __webpack_require__.e/* import() */(0) 是异步加载 chunk, __webpack_require__.bind(null, 3) 为安装模块。 __webpack_require__.e 主要功能是通过 dom 操作插入 script 标签来异步加载 chunk 对应的 js 文件，新建了一个 Promise 对象 promise，并将 [resolve, reject, promise] 存在 installedChunks 中。 异步加载的 chunk 会执行 webpackJsonp 方法，该方法中会执行 installedChunks 中存放的 resolve 方法，从而通知 modules[4] 中的代码继续执行。 整个过程可以用下图来表示： 提取公共代码1234567891011src js components # 公用组件 layout.js utils # 公用工具模块 utils.js vendor # 基础库 react.js react-dom.js pageA.js pageB.js 有时候网站会由多个页面组成，每个页面都是一个独立的单页面应用，这些页面技术栈相同且包含相同的业务代码，如果每个页面的代码都将这些公共的部分包含进去，势必会造成：1) 相同的资源重复加载 2) 每个页面的体积太大 为了解决这个问题，可以将公共代码提取出来，具体到上面的例子，我们可能希望最终打包的结果像这样： 为了实现上述要求，可以使用 CommonsChunkPlugin: 123456789101112131415161718192021222324252627const path = require('path')const webpack = require('webpack')module.exports = &#123; entry: &#123; pageA: path.resolve(__dirname, 'src/js/pageA.js'), pageB: path.resolve(__dirname, 'src/js/pageB.js') &#125;, output: &#123; filename: '[name].[chunkhash:8].js', path: path.resolve(__dirname, 'dist'), publicPath: 'dist/', chunkFilename: '[name].js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'common', minChunks: 2 &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: (&#123; resource &#125;) =&gt; ( resource &amp;&amp; resource.indexOf('vendor') &gt;= 0 &amp;&amp; resource.match(/\.js$/) ) &#125;) ]&#125; | 作者：ayou]]></content>
      <categories>
        <category>组内分享</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo写文章]]></title>
    <url>%2F2018%2F06%2F20%2F%E4%BD%BF%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[前言为了发扬光大Shopee DP小组 前端团队一如既往的酷爱工作的热情，我们建立了这个博客，记录工作中遇到的点点滴滴。 正文这里分为两部分，一部分是博客源码，另一部分是操作博客。博客源码存放在github上，相当于博客的砖砖瓦瓦；hexo则是操作工具，用于将这些砖瓦建起来。 博客源码这里是我们的源码，通过git来进行操作管理。每次写博客前记得pull，写完博客发布后别忘了push！ 操作博客安装hexonpm install -g hexo hexo安装完成后，安装依赖包 npm install 这里是hexo的一些常用命令，不需要记，后面用到了再来看就行 12345hexo g # hexo generate 命令的简写，用于生成静态文件hexo s # hexo server 命令的简写，用于启动服务器进行本地预览hexo d # hexo deploy 命令的简写，用于将本地文件发布到github上hexo n # hexo new 命令的简写，用于新建一篇文章hexo clean # 清除缓存文件（db.json）和已生成的静态文件（public） 执行以下命令在本地启动 hexo s 然后通过浏览器访问http://localhost:4000，可以看到博客已经成功运行起来了。这是在本地运行的博客，也就是hexo的本地预览功能。接下来我们来把它挂载到github，让更多人喜欢工作，着迷工作，为工作疯狂。先生成静态文件，执行以下命令 hexo g 接着发布到git上 hexo d 就可以在github上看到我们的博客了，从这里进入 新建文章运行新建文章的命令 hexo n &quot;文章名字&quot; 可以看到在本地的 ./source/_post/文件夹中已经新生成了一个md文件，hexo中文章是用markdown来写的123456title: my new post #可以改成中文的，如“新文章”date: 2018-06-20 17:16:15 #发表日期，一般不改动categories: blog #文章文类tags: [文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写 插入图片markdown中插入图片的语法 ![Alt text](image path) 对于网上图片，只需要将图片的链接地址写入image path即可； 对于本地图片，需要将图片存入/source/images/文件夹中，再将相对地址/images/图片名称 写入image path，例如 1![Dk](/images/WechatIMG2.jpeg) 由于markdown没有控制图片大小的语法，所以控制图片大小要用 &lt;img&gt; 标签实现，例如 1&lt;img src=&apos;/images/WechatIMG2.jpeg&apos; style=&apos;width: 200px;&apos;/&gt; 发布文章写完之后通过 hexo s 在本地预览效果，满意之后再发布到git上，但是这里要注意，最好在前面再加上hexo clean以清除缓存文件和已生成的静态文件，避免没法正常提交新文件的错误。 hexo clean hexo d hexo g 将文章同步到github上。最后记得git push将改动同步到源码上~ 三、参考嘟嘟独立博客 hexo干活系列：（一）hexo+github搭建个人独立博客 | 作者：Dk]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
