<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git常用指令]]></title>
    <url>%2F2018%2F07%2F11%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析 webpack 打包机制]]></title>
    <url>%2F2018%2F07%2F11%2Fwebpack-bundle-dive-into%2F</url>
    <content type="text"><![CDATA[从最基本的开始首先，让我们从一个简单的例子开始： 12345678src js constants.js index.js utils.js index.htmlpackage.jsonwebpack.config.js 其中，各文件内容如下： 1234567891011121314151617181920212223242526272829303132333435// index.jsconst sum = require('./utils').sumconst CONST = require('./constants')console.log(sum(1, 2))console.log(CONST.version)// utils.jsexports.sum = (a, b) =&gt; &#123; return a + b&#125;// constants.jsmodule.exports = &#123; version: '1.1.0'&#125;// webpack.config.jsconst path = require('path')module.exports = &#123; entry: './src/js/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;// index.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;...&lt;body&gt;&lt;div&gt;hello&lt;/div&gt; &lt;script src="./dist/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打包出的结果经过简化后如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// webpackBootstrap 启动函数// modules 即为存放所有模块的数组，数组中的每一个元素都是一个函数(function (modules) &#123; // 安装后的模块缓存在该对象中 var installedModules = &#123;&#125;; // 模块加载函数，跟 node.js 中的 require 语句类似 // moduleId 为模块在数组 modules 中的索引 function __webpack_require__(moduleId) &#123; // 如果模块已经加载过，直接从缓存中返回 if (installedModules[moduleId]) return installedModules[moduleId].exports; // 如果缓存中不存在需要加载的模块，就新建一个模块，存放在缓存中 var module = installedModules[moduleId] = &#123; i: moduleId, // 模块在数组中的索引 l: false, // 还未加载 exports: &#123;&#125; // 该模块的导出对象 &#125;; // 执行模块函数 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 将模块标记为已加载 module.l = true; // 返回该模块的导出对象 return module.exports; &#125; // 使用 __webpack_require__ 去加载 index 为 2 的模块，并且返回该模块导出的对象 // __webpack_require__.s 表示该模块是启动模块 return __webpack_require__(__webpack_require__.s = 2);&#125;)([ /* 0 */ (function (module, exports) &#123; module.exports = &#123; version: '1.1.0' &#125; &#125;), /* 1 */ (function (module, exports) &#123; exports.sum = (a, b) =&gt; &#123; return a + b &#125; &#125;), /* 2 */ (function (module, exports, __webpack_require__) &#123; const sum = __webpack_require__(1).sum const CONST = __webpack_require__(0) console.log(sum(1, 2)) console.log(CONST.version) &#125;)]); 打包后的结果是一个自执行函数，其参数是一个数组，存储了各个模块，每个模块就是一个函数，其参数分别为 module, exports, __webpack_require__，每个模块以数组下标作为模块的 id。 自执行函数中定义了函数 __webpack_require__(moduleId)， 该函数类似于 nodejs 中的 require，其参数为模块 id，该函数首先判断模块是否已加载到 installedModules 对象之中，如果是，则直接返回缓存的结果，否则就新创建一个模块对象，并执行模块对应的函数，最后返回模块导出的内容。 自执行函数最后调用 __webpack_require__(__webpack_require__.s = 2) 并传入了入口模块的 id，这样整个应用就跑起来了。 模块异步加载假设我们的入口模块代码如下： 123456789101112131415import('./page1').then(page =&gt; &#123; console.log(page)&#125;)import('./page2').then(page =&gt; &#123; console.log(page)&#125;)import('./page3').then(page =&gt; &#123; console.log(page)&#125;)import('./page4').then(page =&gt; &#123; console.log(page)&#125;) 打包后的结果： bundle.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147(function(modules) &#123; // webpackBootstrap // install a JSONP callback for chunk loading var parentJsonpFunction = window["webpackJsonp"]; /** * 从异步加载的文件中安装模块 * @param &#123;*&#125; chunkIds 异步加载的文件中存放的需要安装的模块对应的 chunk id（包括自己），可以理解为所依赖的 chunk id * @param &#123;*&#125; moreModules 表示该 chunk 加载后新带来的 modules * @param &#123;*&#125; executeModules 需要执行的模块，可能为空 */ window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) &#123; var moduleId, chunkId, i = 0, resolves = [], result; for(;i &lt; chunkIds.length; i++) &#123; chunkId = chunkIds[i]; if(installedChunks[chunkId]) // 将 resolve 放到队列中后面统一执行 resolves.push(installedChunks[chunkId][0]); // 标记该 chunk 加载成功 installedChunks[chunkId] = 0; &#125; // 将 chunk 中的 modules 合并到 modules 中 for(moduleId in moreModules) &#123; if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; modules[moduleId] = moreModules[moduleId]; &#125; &#125; if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules); while(resolves.length) resolves.shift()(); &#125;; // The module cache var installedModules = &#123;&#125;; // objects to store loaded and loading chunks var installedChunks = &#123; 4: 0 &#125;; // The require function function __webpack_require__(moduleId) &#123; // Check if module is in cache if(installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.l = true; // Return the exports of the module return module.exports; &#125; /** * 异步加载分割出去的chunk对应的文件 * @param &#123;*&#125; chunkId 需要异步加载的 chunk 对应的 id */ __webpack_require__.e = function requireEnsure(chunkId) &#123; // 状态为 0 表示已经加载过 if(installedChunks[chunkId] === 0) return Promise.resolve(); // 不为 0 且不为空，表示正在加载，其实返回的是一个 Promise 对象，后面会看到 if(installedChunks[chunkId]) &#123; return installedChunks[chunkId][2]; &#125; // 通过 dom 操作插入 script 标签来异步加载 chunk 对应的 js 文件 var head = document.getElementsByTagName('head')[0]; var script = document.createElement('script'); script.type = 'text/javascript'; script.charset = 'utf-8'; script.async = true; script.timeout = 120000; // CSP 相关 if (__webpack_require__.nc) &#123; script.setAttribute("nonce", __webpack_require__.nc); &#125; // 文件的路径由配置的 publicPath, chunkId 拼接而成 script.src = __webpack_require__.p + "" + chunkId + ".bundle.js"; // 异步加载超时时间 var timeout = setTimeout(onScriptComplete, 120000); // 加载失败或成功的回调函数 script.onerror = script.onload = onScriptComplete; function onScriptComplete() &#123; // 防止 IE 中内存泄漏 script.onerror = script.onload = null; clearTimeout(timeout); // 检查 chunk 是否加载成功，如果不成功则 reject var chunk = installedChunks[chunkId]; if(chunk !== 0) &#123; if(chunk) chunk[1](new Error('Loading chunk ' + chunkId + ' failed.')); installedChunks[chunkId] = undefined; &#125; &#125;; // 返回的 promise，初始化 installedChunks[chunkId] 为 [resolve, reject, promise] // 什么时候 resolve ? var promise = new Promise(function(resolve, reject) &#123; installedChunks[chunkId] = [resolve, reject]; &#125;); installedChunks[chunkId][2] = promise; head.appendChild(script); return promise; &#125;; // __webpack_public_path__ __webpack_require__.p = "dist/"; // Load entry module and return exports return __webpack_require__(__webpack_require__.s = 4);&#125;)(&#123;// 0 - 3 的 modules 被分割出去了/***/ 4:/***/ (function(module, exports, __webpack_require__) &#123;__webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, 0)).then(page =&gt; &#123; console.log(page)&#125;)__webpack_require__.e/* import() */(2).then(__webpack_require__.bind(null, 1)).then(page =&gt; &#123; console.log(page)&#125;)__webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 2)).then(page =&gt; &#123; console.log(page)&#125;)__webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 3)).then(page =&gt; &#123; console.log(page)&#125;)/***/ &#125;)&#125;); 0.bundle.js 1234567891011webpackJsonp([0],&#123;/***/ 3:/***/ (function(module, exports) &#123;exports.name = 'page1'/***/ &#125;)&#125;); bundle.js 中 modules[4] 模块中执行的 __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 3)).then(...) 可以分解为两步：其中 __webpack_require__.e/* import() */(0) 是异步加载 chunk, __webpack_require__.bind(null, 3) 为安装模块。 __webpack_require__.e 主要功能是通过 dom 操作插入 script 标签来异步加载 chunk 对应的 js 文件，新建了一个 Promise 对象 promise，并将 [resolve, reject, promise] 存在 installedChunks 中。 异步加载的 chunk 会执行 webpackJsonp 方法，该方法中会执行 installedChunks 中存放的 resolve 方法，从而通知 modules[4] 中的代码继续执行。 整个过程可以用下图来表示： 提取公共代码1234567891011src js components # 公用组件 layout.js utils # 公用工具模块 utils.js vendor # 基础库 react.js react-dom.js pageA.js pageB.js 有时候网站会由多个页面组成，每个页面都是一个独立的单页面应用，这些页面技术栈相同且包含相同的业务代码，如果每个页面的代码都将这些公共的部分包含进去，势必会造成：1) 相同的资源重复加载 2) 每个页面的体积太大 为了解决这个问题，可以将公共代码提取出来，具体到上面的例子，我们可能希望最终打包的结果像这样： 为了实现上述要求，可以使用 CommonsChunkPlugin: 123456789101112131415161718192021222324252627const path = require('path')const webpack = require('webpack')module.exports = &#123; entry: &#123; pageA: path.resolve(__dirname, 'src/js/pageA.js'), pageB: path.resolve(__dirname, 'src/js/pageB.js') &#125;, output: &#123; filename: '[name].[chunkhash:8].js', path: path.resolve(__dirname, 'dist'), publicPath: 'dist/', chunkFilename: '[name].js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'common', minChunks: 2 &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: (&#123; resource &#125;) =&gt; ( resource &amp;&amp; resource.indexOf('vendor') &gt;= 0 &amp;&amp; resource.match(/\.js$/) ) &#125;) ]&#125; | 作者：ayou]]></content>
      <categories>
        <category>组内分享</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo写文章]]></title>
    <url>%2F2018%2F06%2F20%2F%E4%BD%BF%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[前言为了发扬光大Shopee DP小组 前端团队一如既往的酷爱工作的热情，我们建立了这个博客，记录工作中遇到的点点滴滴。 正文这里分为两部分，一部分是博客源码，另一部分是操作博客。博客源码存放在github上，相当于博客的砖砖瓦瓦；hexo则是操作工具，用于将这些砖瓦建起来。 博客源码这里是我们的源码，通过git来进行操作管理。每次写博客前记得pull，写完博客发布后别忘了push！ 操作博客安装hexonpm install -g hexo hexo安装完成后，安装依赖包 npm install 这里是hexo的一些常用命令，不需要记，后面用到了再来看就行 12345hexo g # hexo generate 命令的简写，用于生成静态文件hexo s # hexo server 命令的简写，用于启动服务器进行本地预览hexo d # hexo deploy 命令的简写，用于将本地文件发布到github上hexo n # hexo new 命令的简写，用于新建一篇文章hexo clean # 清除缓存文件（db.json）和已生成的静态文件（public） 执行以下命令在本地启动 hexo s 然后通过浏览器访问http://localhost:4000，可以看到博客已经成功运行起来了。这是在本地运行的博客，也就是hexo的本地预览功能。接下来我们来把它挂载到github，让更多人喜欢工作，着迷工作，为工作疯狂。先生成静态文件，执行以下命令 hexo g 接着发布到git上 hexo d 就可以在github上看到我们的博客了，从这里进入 新建文章运行新建文章的命令 hexo n &quot;文章名字&quot; 可以看到在本地的 ./source/_post/文件夹中已经新生成了一个md文件，hexo中文章是用markdown来写的123456title: my new post #可以改成中文的，如“新文章”date: 2018-06-20 17:16:15 #发表日期，一般不改动categories: blog #文章文类tags: [文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写 插入图片markdown中插入图片的语法 ![Alt text](image path) 对于网上图片，只需要将图片的链接地址写入image path即可； 对于本地图片，需要将图片存入/source/images/文件夹中，再将相对地址/images/图片名称 写入image path，例如 1![Dk](/images/WechatIMG2.jpeg) 由于markdown没有控制图片大小的语法，所以控制图片大小要用 &lt;img&gt; 标签实现，例如 1&lt;img src=&apos;/images/WechatIMG2.jpeg&apos; style=&apos;width: 200px;&apos;/&gt; 发布文章写完之后通过 hexo s 在本地预览效果，满意之后再发布到git上，但是这里要注意，最好在前面再加上hexo clean以清除缓存文件和已生成的静态文件，避免没法正常提交新文件的错误。 hexo clean hexo d hexo g 将文章同步到github上。最后记得git push将改动同步到源码上~ 三、参考嘟嘟独立博客 hexo干活系列：（一）hexo+github搭建个人独立博客]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
