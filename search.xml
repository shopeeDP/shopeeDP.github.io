<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dp 项目部署说明]]></title>
    <url>%2F2018%2F07%2F11%2Fshopee-deploy%2F</url>
    <content type="text"><![CDATA[shopee 前端项目部署涉及的点比较多，且部署过程中有些环节对于我们开发人员来说是黑盒，很容易掉坑，为了降低大家的采坑概率，将自己摸索的经验总结如下 生产环境目录说明shopee 中每个项目对应到生产环境中都会有如下所示的一个目录： 1/data/shopee/&#123;&#123; env &#125;&#125;/&#123;&#123; project_name &#125;&#125;-&#123;&#123; cid &#125;&#125;/ 其中 project_name 是项目名称，对应到我们组就是 dp，env 是环境，可选项为 test, live 等，cid 是国家代号，可选项为 id(印尼), sg(新加坡), th(泰国) 等。由于 dp 项目下有很多前端子项目，如 sniper, windrunner, hub-admin 等，所以我们需要通过文件目录来区分各个项目，如下所示： 12345678910111213141516171819/data/shopee/test/dp-id# tree -L 2...........├── hub│ ├── favicon.ico│ ├── index.html│ └── static├── sniper│ ├── asset-manifest.json│ ├── index.html│ ├── manifest.json│ ├── service-worker.js│ └── static├── windrunner│ ├── favicon.png│ ├── index.20e07574.js│ ├── index.e20816cc.css│ ├── index.html│ └── static.......... 所以，我们前端项目打包的路径就必须要进行调整，下面以 hub-admin 为例来说说单个项目如何打包： 项目打包设置首先每个前端项目下必须要有一个 deploy 目录，下面包含项目部署配置文件，文件名必须同 jenkin 上的 module 名称一致。以 hub-admin 项目 test 环境为例，其在 jenken 上的名称为 shopee-dp-hubstatic-test，所以 deploy 下的配置文件名应该为 hubstatic.json，下面看看该文件： 1234567891011121314151617181920212223242526272829&#123; "project_dir_depth": 2, "project_name": "dp", "module_name": "hubstatic", "install": &#123; "commands": [ ] &#125;, "build": &#123; "docker_image": &#123; "base_image": "harbor.shopeemobile.com/shopee/nodejs-base", "squash": false, "dependent_libraries_files": [ "package.json" ], "run_commands": [ "npm install" ] &#125;, "commands": [ "npm run build" ], "upload_static": &#123; "static_dir": "dist", "enable_cdn": false &#125; &#125;&#125; 文件中配置的含义请参考这里，另外，如何申请一个新的 jenkin 部署项目请看这里。 其中， upload_static 下面的 static_dir 指定的路径下面的文件会在部署的时候全部拷贝到前一节所说的目录之下，具体来说就是 /data/shopee/test/dp-id，所以我们打包出来的结果应该如下所示： 1234567└── hub ├── index.html └── static ├── css ├── fonts ├── img └── js index.html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=utf-8&gt; &lt;meta name=viewport content="width=device-width,initial-scale=1"&gt; &lt;title&gt;SHOPEE Hub Admin&lt;/title&gt; &lt;link rel="shortcut icon" href=/hub/favicon.ico&gt; &lt;!-- 这里的 basename "hub" 不一定要和上面的目录名 hub 一致，sniper 项目就是一个例子--&gt; &lt;link href=/hub/static/css/app.0edc75456c91cd763270c8d0c769e143.css rel=stylesheet&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=app&gt;&lt;/div&gt; &lt;script type=text/javascript src=/hub/static/js/manifest.ce3d40e477b8ed629793.js&gt;&lt;/script&gt; &lt;script type=text/javascript src=/hub/static/js/vendor.494ab495d29c7629ae55.js&gt;&lt;/script&gt; &lt;script type=text/javascript src=/hub/static/js/app.ba67cad897139a164db1.js&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 具体如何设置请参考 webpack 官网或 dp 现有项目。 nginx 配置dp 组现有 sniper, windrunner, hub-admin 前端项目，下面详细说明下三个项目的 nginx 配置： 项目 访问地址 nginx配置地址 sniper https://shopee.co.id/produk-digital/m mall.conf.j2 可以搜索 produk-digital 快速定位 windrunner https://dp-admin.test.shopee.io/windrunner dp.conf.j2 hub-admin https://dp-admin.test.shopee.io/hub dp.conf.j2 其中 sniper 是放在 shopee.co.id 域名下的，所以它的配置写在 mall.conf.j2 里面，而 windrunner 和 hub-admin 两者是在同一个域名下通过 pathname 来区分，所以他们的配置都写在 dp.conf.j2 里面。下面详细介绍一下他们的配置： sniper 1234567891011121314151617181920212223242526272829303132## begin of digital purchase ##&#123;% if cid in [&quot;id&quot;] %&#125; # 印尼location /produk-digital/m &#123; # 形如 /produk-digital/m/*** 的路由都会被导流到 /produk-digital/m/index.html 下 try_files $uri /produk-digital/m/index.html;&#125;location = /produk-digital/m/index.html &#123; # 上面的 location 都导流到了这里 alias /data/shopee/&#123;&#123; env &#125;&#125;/dp-&#123;&#123; cid &#125;&#125;/sniper/index.html; # 所有非静态文件的请求都返回 index.html 文件 access_log off; add_header Cache-Control &quot;no-cache, no-store&quot;; expires -1; etag on; include gzip_params;&#125;location /digital-product/static/ &#123; # 请求 http://test.com/produk-digital/static/css/main.css # 会返回 # /data/shopee/&#123;&#123; env &#125;&#125;/dp-&#123;&#123; cid &#125;&#125;/sniper/static/static/css/main.css alias /data/shopee/&#123;&#123; env &#125;&#125;/dp-&#123;&#123; cid &#125;&#125;/sniper/static/; access_log off; expires 30d; etag on; include gzip_params;&#125;&#123;% endif %&#125;## end of digital purchase ## 由于产品对访问 dp 项目的 url 有地区性的要求，所以印尼版的 url 路径为 /produk-digital/m，以后泰国可能为 /ผลิตภัณฑ์ดิจิตอล/m，而静态文件则没有这种要求，可以保持 /digital-product/static/ 不变。 dp.conf.j2 123456789101112131415161718192021222324252627282930313233343536373839404142434445## Start of hub_admin ##location /hub/static/ &#123; alias /data/shopee/&#123;&#123; env &#125;&#125;/&#123;&#123; project_name &#125;&#125;-&#123;&#123; cid &#125;&#125;/hub/static/; expires 30d; access_log off; include gzip_params;&#125;location /hub &#123; try_files $uri /hub/index.html;&#125;location = /hub/index.html &#123; alias /data/shopee/&#123;&#123; env &#125;&#125;/&#123;&#123; project_name &#125;&#125;-&#123;&#123; cid &#125;&#125;/hub/index.html; expires -1; etag on; include gzip_params;&#125;## End of hub_admin #### Start of dp_admin_portal ##location /windrunner/static/ &#123; alias /data/shopee/&#123;&#123; env &#125;&#125;/&#123;&#123; project_name &#125;&#125;-&#123;&#123; cid &#125;&#125;/windrunner/static/; expires 30d; access_log off; include gzip_params;&#125;location /windrunner &#123; try_files $uri /windrunner/index.html;&#125;location = /windrunner/index.html &#123; alias /data/shopee/&#123;&#123; env &#125;&#125;/&#123;&#123; project_name &#125;&#125;-&#123;&#123; cid &#125;&#125;/windrunner/index.html; expires -1; etag on; include gzip_params;&#125;## End of dp_admin_portal ## 各配置的含义同 sniper 类似，就不赘述了。 下面说明一下修改 nginx 配置的流程： 从 master 分支上 checkout 一个分支。 在 jira 上新建一个问题，格式如下所示： 在新建的分支上进行修改，然后发起合并请求到 test 或者 master 分支，将 jira 单号写到合并请求标题中，如：[SPTOS-882] live chang dp admin nginx configuration。 总结本文只是对现有的项目进行了一个介绍，以后遇到其他需求都可以参考现阶段项目的配置。在进行添加或修改之前最好在本地搭建一个 nginx 环境模拟一下，然后再更新到线上环境中。]]></content>
      <categories>
        <category>项目文档</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F07%2F11%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"></content>
      <categories>
        <category>组内分享</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析 webpack 打包机制]]></title>
    <url>%2F2018%2F07%2F11%2Fwebpack-bundle-dive-into%2F</url>
    <content type="text"><![CDATA[从最基本的开始首先，让我们从一个简单的例子开始： 12345678src js constants.js index.js utils.js index.htmlpackage.jsonwebpack.config.js 其中，各文件内容如下： 1234567891011121314151617181920212223242526272829303132333435// index.jsconst sum = require('./utils').sumconst CONST = require('./constants')console.log(sum(1, 2))console.log(CONST.version)// utils.jsexports.sum = (a, b) =&gt; &#123; return a + b&#125;// constants.jsmodule.exports = &#123; version: '1.1.0'&#125;// webpack.config.jsconst path = require('path')module.exports = &#123; entry: './src/js/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;// index.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;...&lt;body&gt;&lt;div&gt;hello&lt;/div&gt; &lt;script src="./dist/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打包出的结果经过简化后如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// webpackBootstrap 启动函数// modules 即为存放所有模块的数组，数组中的每一个元素都是一个函数(function (modules) &#123; // 安装后的模块缓存在该对象中 var installedModules = &#123;&#125;; // 模块加载函数，跟 node.js 中的 require 语句类似 // moduleId 为模块在数组 modules 中的索引 function __webpack_require__(moduleId) &#123; // 如果模块已经加载过，直接从缓存中返回 if (installedModules[moduleId]) return installedModules[moduleId].exports; // 如果缓存中不存在需要加载的模块，就新建一个模块，存放在缓存中 var module = installedModules[moduleId] = &#123; i: moduleId, // 模块在数组中的索引 l: false, // 还未加载 exports: &#123;&#125; // 该模块的导出对象 &#125;; // 执行模块函数 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 将模块标记为已加载 module.l = true; // 返回该模块的导出对象 return module.exports; &#125; // 使用 __webpack_require__ 去加载 index 为 2 的模块，并且返回该模块导出的对象 // __webpack_require__.s 表示该模块是启动模块 return __webpack_require__(__webpack_require__.s = 2);&#125;)([ /* 0 */ (function (module, exports) &#123; module.exports = &#123; version: '1.1.0' &#125; &#125;), /* 1 */ (function (module, exports) &#123; exports.sum = (a, b) =&gt; &#123; return a + b &#125; &#125;), /* 2 */ (function (module, exports, __webpack_require__) &#123; const sum = __webpack_require__(1).sum const CONST = __webpack_require__(0) console.log(sum(1, 2)) console.log(CONST.version) &#125;)]); 打包后的结果是一个自执行函数，其参数是一个数组，存储了各个模块，每个模块就是一个函数，其参数分别为 module, exports, __webpack_require__，每个模块以数组下标作为模块的 id。 自执行函数中定义了函数 __webpack_require__(moduleId)， 该函数类似于 nodejs 中的 require，其参数为模块 id，该函数首先判断模块是否已加载到 installedModules 对象之中，如果是，则直接返回缓存的结果，否则就新创建一个模块对象，并执行模块对应的函数，最后返回模块导出的内容。 自执行函数最后调用 __webpack_require__(__webpack_require__.s = 2) 并传入了入口模块的 id，这样整个应用就跑起来了。 模块异步加载假设我们的入口模块代码如下： 123456789101112131415import('./page1').then(page =&gt; &#123; console.log(page)&#125;)import('./page2').then(page =&gt; &#123; console.log(page)&#125;)import('./page3').then(page =&gt; &#123; console.log(page)&#125;)import('./page4').then(page =&gt; &#123; console.log(page)&#125;) 打包后的结果： bundle.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147(function(modules) &#123; // webpackBootstrap // install a JSONP callback for chunk loading var parentJsonpFunction = window["webpackJsonp"]; /** * 从异步加载的文件中安装模块 * @param &#123;*&#125; chunkIds 异步加载的文件中存放的需要安装的模块对应的 chunk id（包括自己），可以理解为所依赖的 chunk id * @param &#123;*&#125; moreModules 表示该 chunk 加载后新带来的 modules * @param &#123;*&#125; executeModules 需要执行的模块，可能为空 */ window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) &#123; var moduleId, chunkId, i = 0, resolves = [], result; for(;i &lt; chunkIds.length; i++) &#123; chunkId = chunkIds[i]; if(installedChunks[chunkId]) // 将 resolve 放到队列中后面统一执行 resolves.push(installedChunks[chunkId][0]); // 标记该 chunk 加载成功 installedChunks[chunkId] = 0; &#125; // 将 chunk 中的 modules 合并到 modules 中 for(moduleId in moreModules) &#123; if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; modules[moduleId] = moreModules[moduleId]; &#125; &#125; if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules); while(resolves.length) resolves.shift()(); &#125;; // The module cache var installedModules = &#123;&#125;; // objects to store loaded and loading chunks var installedChunks = &#123; 4: 0 &#125;; // The require function function __webpack_require__(moduleId) &#123; // Check if module is in cache if(installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.l = true; // Return the exports of the module return module.exports; &#125; /** * 异步加载分割出去的chunk对应的文件 * @param &#123;*&#125; chunkId 需要异步加载的 chunk 对应的 id */ __webpack_require__.e = function requireEnsure(chunkId) &#123; // 状态为 0 表示已经加载过 if(installedChunks[chunkId] === 0) return Promise.resolve(); // 不为 0 且不为空，表示正在加载，其实返回的是一个 Promise 对象，后面会看到 if(installedChunks[chunkId]) &#123; return installedChunks[chunkId][2]; &#125; // 通过 dom 操作插入 script 标签来异步加载 chunk 对应的 js 文件 var head = document.getElementsByTagName('head')[0]; var script = document.createElement('script'); script.type = 'text/javascript'; script.charset = 'utf-8'; script.async = true; script.timeout = 120000; // CSP 相关 if (__webpack_require__.nc) &#123; script.setAttribute("nonce", __webpack_require__.nc); &#125; // 文件的路径由配置的 publicPath, chunkId 拼接而成 script.src = __webpack_require__.p + "" + chunkId + ".bundle.js"; // 异步加载超时时间 var timeout = setTimeout(onScriptComplete, 120000); // 加载失败或成功的回调函数 script.onerror = script.onload = onScriptComplete; function onScriptComplete() &#123; // 防止 IE 中内存泄漏 script.onerror = script.onload = null; clearTimeout(timeout); // 检查 chunk 是否加载成功，如果不成功则 reject var chunk = installedChunks[chunkId]; if(chunk !== 0) &#123; if(chunk) chunk[1](new Error('Loading chunk ' + chunkId + ' failed.')); installedChunks[chunkId] = undefined; &#125; &#125;; // 返回的 promise，初始化 installedChunks[chunkId] 为 [resolve, reject, promise] // 什么时候 resolve ? var promise = new Promise(function(resolve, reject) &#123; installedChunks[chunkId] = [resolve, reject]; &#125;); installedChunks[chunkId][2] = promise; head.appendChild(script); return promise; &#125;; // __webpack_public_path__ __webpack_require__.p = "dist/"; // Load entry module and return exports return __webpack_require__(__webpack_require__.s = 4);&#125;)(&#123;// 0 - 3 的 modules 被分割出去了/***/ 4:/***/ (function(module, exports, __webpack_require__) &#123;__webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, 0)).then(page =&gt; &#123; console.log(page)&#125;)__webpack_require__.e/* import() */(2).then(__webpack_require__.bind(null, 1)).then(page =&gt; &#123; console.log(page)&#125;)__webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 2)).then(page =&gt; &#123; console.log(page)&#125;)__webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 3)).then(page =&gt; &#123; console.log(page)&#125;)/***/ &#125;)&#125;); 0.bundle.js 1234567891011webpackJsonp([0],&#123;/***/ 3:/***/ (function(module, exports) &#123;exports.name = 'page1'/***/ &#125;)&#125;); bundle.js 中 modules[4] 模块中执行的 __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 3)).then(...) 可以分解为两步：其中 __webpack_require__.e/* import() */(0) 是异步加载 chunk, __webpack_require__.bind(null, 3) 为安装模块。 __webpack_require__.e 主要功能是通过 dom 操作插入 script 标签来异步加载 chunk 对应的 js 文件，新建了一个 Promise 对象 promise，并将 [resolve, reject, promise] 存在 installedChunks 中。 异步加载的 chunk 会执行 webpackJsonp 方法，该方法中会执行 installedChunks 中存放的 resolve 方法，从而通知 modules[4] 中的代码继续执行。 整个过程可以用下图来表示： 提取公共代码1234567891011src js components # 公用组件 layout.js utils # 公用工具模块 utils.js vendor # 基础库 react.js react-dom.js pageA.js pageB.js 有时候网站会由多个页面组成，每个页面都是一个独立的单页面应用，这些页面技术栈相同且包含相同的业务代码，如果每个页面的代码都将这些公共的部分包含进去，势必会造成：1) 相同的资源重复加载 2) 每个页面的体积太大 为了解决这个问题，可以将公共代码提取出来，具体到上面的例子，我们可能希望最终打包的结果像这样： 为了实现上述要求，可以使用 CommonsChunkPlugin: 123456789101112131415161718192021222324252627const path = require('path')const webpack = require('webpack')module.exports = &#123; entry: &#123; pageA: path.resolve(__dirname, 'src/js/pageA.js'), pageB: path.resolve(__dirname, 'src/js/pageB.js') &#125;, output: &#123; filename: '[name].[chunkhash:8].js', path: path.resolve(__dirname, 'dist'), publicPath: 'dist/', chunkFilename: '[name].js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'common', minChunks: 2 &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: (&#123; resource &#125;) =&gt; ( resource &amp;&amp; resource.indexOf('vendor') &gt;= 0 &amp;&amp; resource.match(/\.js$/) ) &#125;) ]&#125; | 作者：ayou]]></content>
      <categories>
        <category>组内分享</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo写文章]]></title>
    <url>%2F2018%2F06%2F20%2F%E4%BD%BF%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[前言为了发扬光大Shopee DP小组 前端团队一如既往的酷爱工作的热情，我们建立了这个博客，记录工作中遇到的点点滴滴。 正文这里分为两部分，一部分是博客源码，另一部分是操作博客。博客源码存放在github上，相当于博客的砖砖瓦瓦；hexo则是操作工具，用于将这些砖瓦建起来。 博客源码这里是我们的源码，通过git来进行操作管理。每次写博客前记得pull，写完博客发布后别忘了push！ 操作博客安装hexonpm install -g hexo hexo安装完成后，安装依赖包 npm install 这里是hexo的一些常用命令，不需要记，后面用到了再来看就行 12345hexo g # hexo generate 命令的简写，用于生成静态文件hexo s # hexo server 命令的简写，用于启动服务器进行本地预览hexo d # hexo deploy 命令的简写，用于将本地文件发布到github上hexo n # hexo new 命令的简写，用于新建一篇文章hexo clean # 清除缓存文件（db.json）和已生成的静态文件（public） 执行以下命令在本地启动 hexo s 然后通过浏览器访问http://localhost:4000，可以看到博客已经成功运行起来了。这是在本地运行的博客，也就是hexo的本地预览功能。接下来我们来把它挂载到github，让更多人喜欢工作，着迷工作，为工作疯狂。先生成静态文件，执行以下命令 hexo g 接着发布到git上 hexo d 就可以在github上看到我们的博客了，从这里进入 新建文章运行新建文章的命令 hexo n &quot;文章名字&quot; 可以看到在本地的 ./source/_post/文件夹中已经新生成了一个md文件，hexo中文章是用markdown来写的123456title: my new post #可以改成中文的，如“新文章”date: 2018-06-20 17:16:15 #发表日期，一般不改动categories: blog #文章文类tags: [文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写 插入图片markdown中插入图片的语法 ![Alt text](image path) 对于网上图片，只需要将图片的链接地址写入image path即可； 对于本地图片，需要将图片存入/source/images/文件夹中，再将相对地址/images/图片名称 写入image path，例如 1![Dk](/images/WechatIMG2.jpeg) 由于markdown没有控制图片大小的语法，所以控制图片大小要用 &lt;img&gt; 标签实现，例如 1&lt;img src=&apos;/images/WechatIMG2.jpeg&apos; style=&apos;width: 200px;&apos;/&gt; 发布文章写完之后通过 hexo s 在本地预览效果，满意之后再发布到git上，但是这里要注意，最好在前面再加上hexo clean以清除缓存文件和已生成的静态文件，避免没法正常提交新文件的错误。 hexo clean hexo d hexo g 将文章同步到github上。最后记得git push将改动同步到源码上~ 三、参考嘟嘟独立博客 hexo干活系列：（一）hexo+github搭建个人独立博客 | 作者：Dk]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
